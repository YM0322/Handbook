# Python 项目企业级日志添加指南

## 目录
0. [快速入门：从零开始为新项目添加日志](#0-快速入门从零开始为新项目添加日志)
1. [日志系统概述](#1-日志系统概述)
2. [日志配置管理](#2-日志配置管理)
3. [日志目录结构](#3-日志目录结构)
4. [日志格式设计](#4-日志格式设计)
5. [控制台输出与文件保存详解](#5-控制台输出与文件保存详解)
6. [为特定模块配置独立日志文件](#6-为特定模块配置独立日志文件)
7. [日志级别使用](#7-日志级别使用)
8. [日志添加位置](#8-日志添加位置)
9. [实践步骤](#9-实践步骤)
10. [最佳实践](#10-最佳实践)
11. [常见问题](#11-常见问题)
12. [总结](#12-总结)
13. [附录](#13-附录)

---

## 0. 快速入门：从零开始为新项目添加日志

如果你拿到一个没有任何日志记录系统的新项目，按照以下步骤可以快速添加完整的日志功能。

### 0.0 超简单版本（3分钟上手）

如果你只想快速添加日志功能，不想创建配置文件，可以直接在代码中使用：

**最简单的方式**：在任何 Python 文件开头添加以下代码：

```python
import logging
import os

# 创建 logs 目录
if not os.path.exists('logs'):
    os.makedirs('logs')

# 配置日志：保存到文件
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler('logs/app.log', encoding='utf-8'),
        logging.StreamHandler()  # 同时输出到控制台
    ]
)

# 获取日志记录器
logger = logging.getLogger(__name__)

# 现在就可以使用了
logger.info("程序启动")
logger.debug("这是调试信息")
logger.error("这是错误信息")
```

**缺点**：这种方式日志文件不会自动轮转，文件会一直增长。适合快速测试，生产环境建议使用下面的完整配置。

---

### 0.1 第一步：创建日志配置文件（推荐方式）

在你的项目根目录下创建 `config` 文件夹（如果不存在），然后创建 `config/logging_config.py` 文件：

```python
"""
日志配置文件
最简单的配置：所有日志保存到一个文件
"""

import os
import logging
from logging.handlers import TimedRotatingFileHandler

# 获取项目根目录
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# 日志目录
LOG_DIR = os.path.join(BASE_DIR, 'logs')

# 确保日志目录存在
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)

# 日志文件路径
LOG_FILE = os.path.join(LOG_DIR, 'app.log')

# 配置日志格式
LOG_FORMAT = '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s'
DATE_FORMAT = '%Y-%m-%d %H:%M:%S'

# 创建日志记录器
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)  # 设置最低日志级别

# 清除已有的处理器（避免重复）
logger.handlers.clear()

# 创建文件处理器（按天滚动）
file_handler = TimedRotatingFileHandler(
    filename=LOG_FILE,
    when='midnight',      # 每天午夜轮转
    interval=1,           # 间隔1天
    backupCount=30,       # 保留30天的日志
    encoding='utf-8'
)
file_handler.setLevel(logging.DEBUG)  # 文件记录所有级别的日志

# 创建控制台处理器（可选，用于开发时查看）
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)  # 控制台只显示 INFO 及以上级别

# 创建格式器
formatter = logging.Formatter(LOG_FORMAT, DATE_FORMAT)
file_handler.setFormatter(formatter)
console_handler.setFormatter(formatter)

# 添加处理器到日志记录器
logger.addHandler(file_handler)
logger.addHandler(console_handler)
```

**说明**：
- 所有日志会保存到 `logs/app.log` 文件
- 日志文件每天午夜自动轮转，保留30天
- 控制台会显示 INFO 及以上级别的日志（开发时方便查看）
- 文件会记录所有级别的日志（DEBUG、INFO、WARNING、ERROR、CRITICAL）

### 0.2 第二步：创建日志工具模块

创建 `utils/logger.py` 文件（如果 `utils` 目录不存在，先创建它）：

```python
"""
日志工具模块
提供统一的日志获取接口
"""

import logging

# 导入日志配置（这会执行配置代码）
try:
    from config.logging_config import logger as root_logger
except ImportError:
    # 如果配置文件不存在，使用默认配置
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    root_logger = logging.getLogger()


def get_logger(name=None):
    """
    获取日志记录器
    
    参数:
        name: 日志记录器名称，通常使用 __name__
              如果不提供，返回根日志记录器
    
    返回:
        Logger 对象
    
    使用示例:
        logger = get_logger(__name__)
        logger.info("这是一条信息日志")
    """
    if name is None:
        return root_logger
    return logging.getLogger(name)
```

### 0.3 第三步：在代码中任意位置添加日志

现在你可以在项目的任何地方使用日志了！

#### 3.1 在 Python 文件中添加日志

**步骤**：
1. 在文件顶部导入日志工具
2. 创建日志记录器
3. 在需要的地方添加日志语句

**示例：在 `main.py` 中添加日志**

```python
"""
主程序文件
"""

# 1. 导入日志工具
from utils.logger import get_logger

# 2. 创建日志记录器（使用当前模块名）
logger = get_logger(__name__)


def main():
    """主函数"""
    # 3. 添加日志
    logger.info("程序启动")
    
    try:
        # 你的业务代码
        result = do_something()
        logger.info(f"操作成功: result={result}")
        
    except Exception as e:
        logger.error(f"操作失败: error={str(e)}", exc_info=True)
        raise
    
    logger.info("程序结束")


def do_something():
    """示例函数"""
    logger.debug("开始执行某个操作")
    # 你的代码
    return "success"


if __name__ == '__main__':
    main()
```

#### 3.2 在类中添加日志

**示例：在服务类中添加日志**

```python
"""
服务类示例
"""

from utils.logger import get_logger

# 创建日志记录器
logger = get_logger(__name__)


class UserService:
    """用户服务类"""
    
    def __init__(self):
        logger.info("初始化 UserService")
        # 初始化代码
    
    def create_user(self, username, email):
        """创建用户"""
        logger.info(f"开始创建用户: username={username}, email={email}")
        
        try:
            # 业务逻辑
            user = self._save_user(username, email)
            logger.info(f"用户创建成功: user_id={user.id}")
            return user
            
        except Exception as e:
            logger.error(f"用户创建失败: username={username}, error={str(e)}", exc_info=True)
            raise
    
    def _save_user(self, username, email):
        """保存用户到数据库"""
        logger.debug(f"保存用户到数据库: username={username}")
        # 数据库操作
        return {"id": 1, "username": username}
```

#### 3.3 日志级别使用示例

```python
from utils.logger import get_logger

logger = get_logger(__name__)

# DEBUG: 详细的调试信息（开发时使用）
logger.debug("这是调试信息，通常只在开发时使用")

# INFO: 一般信息，记录程序正常运行的关键步骤
logger.info("用户登录成功: user_id=123")

# WARNING: 警告信息，程序可以继续运行但需要注意
logger.warning("配置文件不存在，使用默认配置")

# ERROR: 错误信息，程序遇到错误但可以继续运行
logger.error("文件读取失败: file_path=/path/to/file")

# CRITICAL: 严重错误，程序可能无法继续运行
logger.critical("数据库连接失败，系统无法继续运行")
```

### 0.4 第四步：验证日志功能

1. **运行你的程序**，执行一些操作
2. **检查日志文件**：查看 `logs/app.log` 文件
3. **查看控制台输出**：应该能看到 INFO 及以上级别的日志

**日志文件示例内容**：
```
2024-01-15 10:30:45 [INFO] __main__:main.py:12 - 程序启动
2024-01-15 10:30:45 [DEBUG] __main__:main.py:25 - 开始执行某个操作
2024-01-15 10:30:46 [INFO] __main__:main.py:15 - 操作成功: result=success
2024-01-15 10:30:46 [INFO] __main__:main.py:18 - 程序结束
```

### 0.5 快速参考：常用日志模式

#### 模式1：函数入口日志
```python
def my_function(param1, param2):
    logger.info(f"函数调用: function=my_function, param1={param1}, param2={param2}")
    # 函数代码
```

#### 模式2：异常捕获日志
```python
try:
    # 可能出错的代码
    result = risky_operation()
except Exception as e:
    logger.error(f"操作失败: operation=risky_operation, error={str(e)}", exc_info=True)
    raise
```

#### 模式3：条件分支日志
```python
if condition:
    logger.info(f"条件满足: condition={condition}")
    # 处理逻辑
else:
    logger.warning(f"条件不满足: condition={condition}")
    # 其他处理
```

#### 模式4：循环中的日志（使用 DEBUG 避免日志过多）
```python
for item in items:
    logger.debug(f"处理项目: item_id={item.id}")
    # 处理逻辑
logger.info(f"处理完成: total_items={len(items)}")
```

### 0.6 常见问题

**Q: 日志文件在哪里？**
A: 默认在项目根目录下的 `logs/app.log` 文件

**Q: 如何修改日志文件路径？**
A: 修改 `config/logging_config.py` 中的 `LOG_FILE` 变量

**Q: 如何修改日志格式？**
A: 修改 `config/logging_config.py` 中的 `LOG_FORMAT` 变量

**Q: 如何只保存到文件，不在控制台显示？**
A: 在 `config/logging_config.py` 中删除或注释掉 `console_handler` 相关的代码

**Q: 如何只记录 ERROR 级别的日志？**
A: 修改 `file_handler.setLevel(logging.ERROR)`

**Q: 日志文件太大怎么办？**
A: 已经配置了按天轮转，每天会自动创建新文件，旧文件保留30天后自动删除

### 0.7 完整示例：一个简单的项目

假设你有一个简单的项目结构：

```
my_project/
├── config/
│   └── logging_config.py    # 日志配置（步骤1）
├── utils/
│   └── logger.py             # 日志工具（步骤2）
├── main.py                   # 主程序
└── services/
    └── user_service.py       # 服务类
```

**main.py**:
```python
from utils.logger import get_logger
from services.user_service import UserService

logger = get_logger(__name__)

def main():
    logger.info("=" * 50)
    logger.info("应用程序启动")
    logger.info("=" * 50)
    
    try:
        service = UserService()
        user = service.create_user("张三", "zhangsan@example.com")
        logger.info(f"用户创建成功: user_id={user['id']}")
        
    except Exception as e:
        logger.error(f"程序执行失败: error={str(e)}", exc_info=True)
    
    finally:
        logger.info("应用程序结束")

if __name__ == '__main__':
    main()
```

**services/user_service.py**:
```python
from utils.logger import get_logger

logger = get_logger(__name__)

class UserService:
    def __init__(self):
        logger.info("初始化 UserService")
    
    def create_user(self, username, email):
        logger.info(f"创建用户: username={username}, email={email}")
        # 模拟创建用户
        user = {"id": 1, "username": username, "email": email}
        logger.info(f"用户创建成功: user_id={user['id']}")
        return user
```

运行程序后，所有日志都会保存到 `logs/app.log` 文件中！

### 0.8 快速入门总结

**3个步骤，5分钟完成**：

1. ✅ **创建配置文件**：`config/logging_config.py`（复制上面的代码）
2. ✅ **创建工具模块**：`utils/logger.py`（复制上面的代码）
3. ✅ **在代码中使用**：
   ```python
   from utils.logger import get_logger
   logger = get_logger(__name__)
   logger.info("你的日志消息")
   ```

**就这么简单！** 现在你的项目就有了完整的日志系统：
- ✅ 所有日志保存到 `logs/app.log`
- ✅ 日志文件按天自动轮转
- ✅ 保留30天的历史日志
- ✅ 控制台显示关键日志（开发时方便查看）
- ✅ 文件记录所有级别的日志

**下一步**：如果你想了解更多企业级日志的最佳实践，继续阅读下面的章节。

---

## 1. 日志系统概述

### 1.1 为什么需要企业级日志

企业级日志系统能够帮助你：
- **问题追踪**：快速定位线上问题
- **性能监控**：分析系统性能瓶颈
- **审计追踪**：记录关键操作，满足合规要求
- **数据分析**：通过日志分析用户行为
- **运维支持**：帮助运维人员快速响应问题

### 1.2 Python 日志模块

Python 标准库提供了 `logging` 模块，功能强大且灵活：
- 支持多种日志级别（DEBUG、INFO、WARNING、ERROR、CRITICAL）
- 支持多种输出方式（控制台、文件、网络等）
- 支持日志轮转（按时间、按大小）
- 支持日志格式自定义

---

## 2. 日志配置管理

### 2.1 配置文件结构

在企业级项目中，日志配置应该通过配置文件管理，而不是硬编码在代码中。推荐使用以下方式：

#### 方式一：使用 logging.config.dictConfig（推荐）

创建 `config/logging_config.py` 文件：

```python
"""
日志配置文件
使用字典配置方式，便于管理和修改
"""

import os
import logging.config
from logging.handlers import TimedRotatingFileHandler

# 获取项目根目录
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# 日志目录
LOG_DIR = os.path.join(BASE_DIR, 'logs')

# 确保日志目录存在
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)

# 日志配置字典
LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    
    # 日志格式器
    'formatters': {
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'detailed': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'simple': {
            'format': '%(asctime)s [%(levelname)s] - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        }
    },
    
    # 日志过滤器（可选）
    'filters': {},
    
    # 日志处理器
    'handlers': {
        # 控制台输出
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'stream': 'ext://sys.stdout'
        },
        
        # 文件输出 - 所有日志
        'file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'app.log'),
            'when': 'midnight',  # 每天午夜轮转
            'interval': 1,       # 间隔1天
            'backupCount': 30,   # 保留30天的日志
            'encoding': 'utf-8',
            'delay': False,
            'utc': False
        },
        
        # 文件输出 - 错误日志
        'error_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'ERROR',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'error.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 90,   # 错误日志保留更长时间
            'encoding': 'utf-8',
            'delay': False,
            'utc': False
        },
        
        # 文件输出 - 访问日志（如果需要）
        'access_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'access.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8',
            'delay': False,
            'utc': False
        }
    },
    
    # 日志记录器
    'loggers': {
        # 根日志记录器
        '': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # 应用主日志记录器
        'app': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # 服务层日志记录器
        'services': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # 数据访问层日志记录器
        'storage': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': False
        }
    }
}
```

#### 方式二：使用 JSON/YAML 配置文件（更灵活）

创建 `config/logging.json` 文件：

```json
{
    "version": 1,
    "disable_existing_loggers": false,
    "formatters": {
        "standard": {
            "format": "%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s",
            "datefmt": "%Y-%m-%d %H:%M:%S"
        },
        "detailed": {
            "format": "%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s",
            "datefmt": "%Y-%m-%d %H:%M:%S"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "level": "INFO",
            "formatter": "standard",
            "stream": "ext://sys.stdout"
        },
        "file": {
            "class": "logging.handlers.TimedRotatingFileHandler",
            "level": "DEBUG",
            "formatter": "detailed",
            "filename": "logs/app.log",
            "when": "midnight",
            "interval": 1,
            "backupCount": 30,
            "encoding": "utf-8"
        },
        "error_file": {
            "class": "logging.handlers.TimedRotatingFileHandler",
            "level": "ERROR",
            "formatter": "detailed",
            "filename": "logs/error.log",
            "when": "midnight",
            "interval": 1,
            "backupCount": 90,
            "encoding": "utf-8"
        }
    },
    "loggers": {
        "": {
            "handlers": ["console", "file", "error_file"],
            "level": "DEBUG",
            "propagate": false
        }
    }
}
```

### 2.2 日志初始化模块

创建 `utils/logger.py` 文件，用于初始化日志系统：

```python
"""
日志工具模块
提供统一的日志初始化和管理功能
"""

import logging
import logging.config
import os
import json
from pathlib import Path

# 尝试从字典配置加载
try:
    from config.logging_config import LOGGING_CONFIG
    USE_DICT_CONFIG = True
except ImportError:
    USE_DICT_CONFIG = False

# 尝试从 JSON 配置加载
CONFIG_JSON_PATH = os.path.join(
    os.path.dirname(os.path.dirname(__file__)),
    'config',
    'logging.json'
)


def setup_logging(config_path=None, default_level=logging.INFO):
    """
    初始化日志系统
    
    参数:
        config_path: 配置文件路径（可选）
        default_level: 默认日志级别
    
    返回:
        None
    """
    if config_path and os.path.exists(config_path):
        # 从 JSON 文件加载配置
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        logging.config.dictConfig(config)
    elif USE_DICT_CONFIG:
        # 从 Python 字典配置加载
        logging.config.dictConfig(LOGGING_CONFIG)
    else:
        # 使用默认配置
        logging.basicConfig(
            level=default_level,
            format='%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )


def get_logger(name=None):
    """
    获取日志记录器
    
    参数:
        name: 日志记录器名称，通常使用 __name__
    
    返回:
        Logger 对象
    """
    if name is None:
        name = __name__
    return logging.getLogger(name)


# 初始化日志系统（在模块导入时自动执行）
setup_logging()
```

---

## 3. 日志目录结构

### 3.1 推荐的目录结构

```
task_manager/
├── logs/                          # 日志根目录
│   ├── app.log                    # 应用主日志（按天滚动）
│   ├── app.log.2024-01-01        # 历史日志文件
│   ├── app.log.2024-01-02
│   ├── error.log                  # 错误日志（按天滚动）
│   ├── error.log.2024-01-01
│   ├── access.log                 # 访问日志（如果需要）
│   ├── access.log.2024-01-01
│   └── archive/                   # 归档目录（可选）
│       └── 2024-01/
│           └── app.log.2024-01-01
├── config/
│   ├── logging_config.py         # 日志配置（Python字典方式）
│   └── logging.json              # 日志配置（JSON方式，可选）
├── utils/
│   └── logger.py                  # 日志工具模块
└── ...
```

### 3.2 目录创建

在 `config.py` 中添加日志目录配置：

```python
# 日志目录
LOG_DIR = os.path.join(BASE_DIR, 'logs')

# 确保日志目录存在
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)
```

### 3.3 日志文件命名规范

- **应用日志**：`app.log`（按天滚动后变为 `app.log.YYYY-MM-DD`）
- **错误日志**：`error.log`（只记录 ERROR 及以上级别）
- **访问日志**：`access.log`（记录用户访问和操作）
- **调试日志**：`debug.log`（开发环境使用，生产环境可关闭）

---

## 4. 日志格式设计

### 4.1 标准日志格式

企业级日志格式应包含以下信息：

```
%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s
```

**格式说明**：
- `%(asctime)s`：时间戳（格式：YYYY-MM-DD HH:MM:SS）
- `%(levelname)s`：日志级别（DEBUG、INFO、WARNING、ERROR、CRITICAL）
- `%(name)s`：日志记录器名称（通常是模块名）
- `%(filename)s`：文件名
- `%(lineno)d`：行号
- `%(message)s`：日志消息

### 4.2 详细日志格式（包含函数名）

```
%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s
```

**额外字段**：
- `%(funcName)s`：函数名

### 4.3 日志格式示例

**标准格式输出示例**：
```
2024-01-15 10:30:45 [INFO] services.task_service:task_service.py:51 [add_task] - 添加新任务: 标题=完成项目文档, ID=5
2024-01-15 10:30:46 [ERROR] services.storage:storage.py:38 [load_tasks] - 读取数据文件时出错: [Errno 2] No such file or directory: 'data/tasks.json'
```

**详细格式输出示例**：
```
2024-01-15 10:30:45 [INFO] services.task_service:task_service.py:51 [add_task] - 添加新任务: 标题=完成项目文档, ID=5
2024-01-15 10:30:46 [ERROR] services.storage:storage.py:38 [load_tasks] - 读取数据文件时出错: [Errno 2] No such file or directory: 'data/tasks.json'
```

### 4.4 日志消息格式建议

日志消息应该包含足够的上下文信息：

**好的日志消息**：
```python
logger.info(f"用户登录成功: user_id={user_id}, ip={ip_address}")
logger.error(f"文件保存失败: file_path={file_path}, error={str(e)}")
logger.debug(f"查询任务列表: filter={{'completed': {completed}}}, 返回数量={len(tasks)}")
```

**不好的日志消息**：
```python
logger.info("成功")  # 缺少上下文
logger.error("错误")  # 缺少错误详情
logger.debug("查询")  # 缺少参数和结果
```

---

## 5. 控制台输出与文件保存详解

### 5.1 什么样的 logger 语句会在控制台打印？

**关键概念**：日志是否在控制台显示，取决于**控制台处理器的日志级别设置**。

#### 当前项目配置分析

根据你的 `config/logging_config.py` 配置：

```python
'console': {
    'class': 'logging.StreamHandler',
    'level': 'INFO',  # ← 这是关键！控制台只显示 INFO 及以上级别
    'formatter': 'standard',
    'stream': 'ext://sys.stdout'
}
```

**控制台会显示的日志级别**：
- ✅ **INFO** - 会在控制台显示
- ✅ **WARNING** - 会在控制台显示
- ✅ **ERROR** - 会在控制台显示
- ✅ **CRITICAL** - 会在控制台显示
- ❌ **DEBUG** - **不会**在控制台显示（但会保存到文件）

#### 实际示例

```python
from utils.logger import get_logger

logger = get_logger(__name__)

# ✅ 这些会在控制台显示
logger.info("这条信息会在控制台显示")
logger.warning("这条警告会在控制台显示")
logger.error("这条错误会在控制台显示")
logger.critical("这条严重错误会在控制台显示")

# ❌ 这条不会在控制台显示（但会保存到文件）
logger.debug("这条调试信息不会在控制台显示")
```

#### 如何修改控制台显示级别？

**方法1：修改配置文件**

在 `config/logging_config.py` 中修改控制台处理器的级别：

```python
'console': {
    'class': 'logging.StreamHandler',
    'level': 'DEBUG',  # 改为 DEBUG，所有级别都会在控制台显示
    'formatter': 'standard',
    'stream': 'ext://sys.stdout'
}
```

**方法2：完全关闭控制台输出**

如果不想在控制台显示任何日志，可以：
1. 删除 `'console'` 处理器
2. 或者在日志记录器的 handlers 列表中移除 `'console'`

```python
'loggers': {
    '': {
        'handlers': ['file', 'error_file'],  # 移除 'console'
        'level': 'DEBUG',
        'propagate': False
    }
}
```

### 5.2 如何将所有日志（包括控制台显示的）保存到一个总日志文件？

**重要理解**：在当前的配置中，**所有日志已经都保存到文件了**！

#### 当前配置的工作原理

```python
'loggers': {
    '': {
        'handlers': ['console', 'file', 'error_file'],  # 同时使用多个处理器
        'level': 'DEBUG',
        'propagate': False
    }
}
```

**这意味着**：
- 一条日志会**同时**发送给所有处理器
- `console` 处理器：根据级别决定是否在控制台显示
- `file` 处理器：**所有 DEBUG 及以上级别**都保存到 `logs/app.log`
- `error_file` 处理器：**所有 ERROR 及以上级别**保存到 `logs/error.log`

#### 验证方法

运行以下测试代码：

```python
from utils.logger import get_logger

logger = get_logger(__name__)

logger.debug("这是 DEBUG 级别")
logger.info("这是 INFO 级别")
logger.warning("这是 WARNING 级别")
logger.error("这是 ERROR 级别")
logger.critical("这是 CRITICAL 级别")
```

**结果**：
- **控制台显示**：INFO、WARNING、ERROR、CRITICAL（4条）
- **`logs/app.log` 文件**：DEBUG、INFO、WARNING、ERROR、CRITICAL（5条，全部）
- **`logs/error.log` 文件**：ERROR、CRITICAL（2条）

#### 如果只想保存到一个总日志文件

如果你希望**所有日志只保存到一个文件**（不分类），可以这样配置：

**修改 `config/logging_config.py`**：

```python
LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    
    'formatters': {
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'detailed': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        }
    },
    
    'handlers': {
        # 控制台输出（可选）
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'stream': 'ext://sys.stdout'
        },
        
        # 唯一的文件处理器 - 保存所有日志
        'file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',  # 记录所有级别
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'app.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8',
            'delay': False,
            'utc': False
        }
    },
    
    'loggers': {
        '': {
            'handlers': ['console', 'file'],  # 只使用 console 和 file
            'level': 'DEBUG',
            'propagate': False
        }
    }
}
```

**这样配置后**：
- ✅ 控制台显示：INFO 及以上级别
- ✅ `logs/app.log` 文件：**所有级别**（DEBUG、INFO、WARNING、ERROR、CRITICAL）
- ❌ 不再有 `error.log` 文件

### 5.3 日志级别与处理器的关系图

```
一条日志（例如 logger.info("消息")）
    │
    ├─→ Logger 级别检查（当前：DEBUG）
    │   └─→ 如果日志级别 >= DEBUG，继续
    │
    ├─→ Console Handler（级别：INFO）
    │   ├─→ 如果日志级别 >= INFO → ✅ 显示在控制台
    │   └─→ 如果日志级别 < INFO → ❌ 不显示
    │
    ├─→ File Handler（级别：DEBUG）
    │   ├─→ 如果日志级别 >= DEBUG → ✅ 保存到 app.log
    │   └─→ 如果日志级别 < DEBUG → ❌ 不保存
    │
    └─→ Error File Handler（级别：ERROR）
        ├─→ 如果日志级别 >= ERROR → ✅ 保存到 error.log
        └─→ 如果日志级别 < ERROR → ❌ 不保存
```

### 5.4 常见场景配置示例

#### 场景1：开发环境 - 控制台显示所有，文件保存所有

```python
'console': {
    'level': 'DEBUG',  # 控制台显示所有
},
'file': {
    'level': 'DEBUG',  # 文件保存所有
}
```

#### 场景2：生产环境 - 控制台只显示重要信息，文件保存所有

```python
'console': {
    'level': 'WARNING',  # 控制台只显示警告和错误
},
'file': {
    'level': 'DEBUG',  # 文件保存所有
}
```

#### 场景3：完全静默 - 不在控制台显示，只保存到文件

```python
'loggers': {
    '': {
        'handlers': ['file'],  # 只有文件处理器
        'level': 'DEBUG',
    }
}
```

### 5.5 总结

**问题1：什么样的 logger 语句会在控制台打印？**
- 答案：**日志级别 >= 控制台处理器级别** 的日志会在控制台显示
- 当前配置：INFO、WARNING、ERROR、CRITICAL 会在控制台显示
- DEBUG 不会在控制台显示（但会保存到文件）

**问题2：如何将所有日志保存到一个总日志文件？**
- 答案：**当前配置已经做到了！** `logs/app.log` 文件包含了所有级别的日志
- 如果只想有一个日志文件：移除 `error_file` 处理器，只保留 `file` 处理器
- 控制台显示和文件保存是**独立的**，互不影响

---

## 6. 为特定模块配置独立日志文件

在实际项目中，经常需要为某些特定的模块或文件单独记录日志。例如：
- 数据库操作日志单独记录
- API 请求日志单独记录
- 某个关键服务的日志单独记录
- 第三方库的日志单独记录

### 6.1 方法一：在配置文件中为特定模块添加独立日志记录器（推荐）

这是最优雅的方式，在 `config/logging_config.py` 中为特定模块配置独立的日志文件。

#### 示例：为 `services.storage` 模块配置独立日志文件

```python
LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    
    'formatters': {
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'detailed': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        }
    },
    
    'handlers': {
        # 控制台输出
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'stream': 'ext://sys.stdout'
        },
        
        # 文件输出 - 所有日志
        'file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'app.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        },
        
        # 文件输出 - 错误日志
        'error_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'ERROR',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'error.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 90,
            'encoding': 'utf-8'
        },
        
        # ⭐ 新增：为 storage 模块配置独立的日志文件
        'storage_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'storage.log'),  # 独立的日志文件
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        },
        
        # ⭐ 新增：为 API 模块配置独立的日志文件
        'api_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, 'api.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        }
    },
    
    'loggers': {
        # 根日志记录器
        '': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # ⭐ 为 storage 模块配置独立的日志记录器
        'services.storage': {
            'handlers': ['console', 'file', 'error_file', 'storage_file'],  # 包含独立的 storage_file
            'level': 'DEBUG',
            'propagate': False  # 重要：设置为 False，避免重复记录
        },
        
        # ⭐ 为 API 模块配置独立的日志记录器（假设有 api 模块）
        'api': {
            'handlers': ['console', 'file', 'error_file', 'api_file'],
            'level': 'INFO',
            'propagate': False
        },
        
        # 其他模块使用默认配置
        'services': {
            'handlers': ['console', 'file', 'error_file'],
            'level': 'DEBUG',
            'propagate': False
        }
    }
}
```

**工作原理**：
1. 创建独立的 handler（如 `storage_file`），指向独立的日志文件
2. 为特定模块创建独立的 logger（如 `services.storage`）
3. 将独立的 handler 添加到该 logger 的 handlers 列表
4. 设置 `propagate: False` 避免日志向上传播导致重复记录

**结果**：
- `services.storage` 模块的日志会同时记录到：
  - `logs/app.log`（所有日志）
  - `logs/error.log`（如果是错误）
  - `logs/storage.log`（**独立文件，只包含 storage 模块的日志**）
  - 控制台（如果是 INFO 及以上级别）

### 6.2 方法二：在代码中动态创建独立日志文件

如果不想修改配置文件，也可以在代码中动态创建独立的日志文件。

#### 示例：为特定模块创建独立日志文件

```python
"""
services/storage.py
为 storage 模块创建独立的日志文件
"""

import logging
from logging.handlers import TimedRotatingFileHandler
import os
from config import LOG_DIR

# 获取当前模块的 logger
logger = logging.getLogger(__name__)  # 名称会是 'services.storage'

# 创建独立的日志文件处理器
storage_log_file = os.path.join(LOG_DIR, 'storage.log')
storage_handler = TimedRotatingFileHandler(
    filename=storage_log_file,
    when='midnight',
    interval=1,
    backupCount=30,
    encoding='utf-8'
)
storage_handler.setLevel(logging.DEBUG)

# 设置格式
formatter = logging.Formatter(
    '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
storage_handler.setFormatter(formatter)

# 添加处理器到 logger（只在当前模块生效）
logger.addHandler(storage_handler)

# 使用 logger
logger.info("这条日志会同时记录到 app.log 和 storage.log")
```

**注意**：这种方式可能会导致日志重复记录，因为根 logger 也会记录。建议使用方法一。

### 6.3 方法三：使用日志工具函数（最灵活）

创建一个工具函数，方便为任意模块创建独立日志文件。

#### 创建工具函数

在 `utils/logger.py` 中添加：

```python
def create_module_logger(module_name, log_file_name, level=logging.DEBUG):
    """
    为特定模块创建独立的日志文件
    
    参数:
        module_name: 模块名称（通常是 __name__）
        log_file_name: 日志文件名（如 'storage.log'）
        level: 日志级别
    
    返回:
        Logger 对象
    
    使用示例:
        logger = create_module_logger(__name__, 'storage.log')
    """
    import os
    from logging.handlers import TimedRotatingFileHandler
    from config import LOG_DIR
    
    # 获取 logger
    logger = logging.getLogger(module_name)
    
    # 创建独立的日志文件处理器
    log_file_path = os.path.join(LOG_DIR, log_file_name)
    handler = TimedRotatingFileHandler(
        filename=log_file_path,
        when='midnight',
        interval=1,
        backupCount=30,
        encoding='utf-8'
    )
    handler.setLevel(level)
    
    # 设置格式
    formatter = logging.Formatter(
        '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    # 添加处理器
    logger.addHandler(handler)
    
    return logger
```

#### 使用工具函数

```python
"""
services/storage.py
"""

from utils.logger import create_module_logger

# 为当前模块创建独立的日志文件
logger = create_module_logger(__name__, 'storage.log', logging.DEBUG)

# 现在可以使用 logger 了
logger.info("这条日志会记录到 storage.log")
```

### 6.4 完整示例：为多个模块配置独立日志文件

假设你的项目结构如下：

```
project/
├── services/
│   ├── storage.py      # 需要独立日志：storage.log
│   ├── api.py          # 需要独立日志：api.log
│   └── task_service.py # 使用默认日志
├── models/
│   └── database.py     # 需要独立日志：database.log
└── config/
    └── logging_config.py
```

**配置文件 `config/logging_config.py`**：

```python
LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    
    'formatters': {
        'detailed': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        }
    },
    
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'detailed',
            'stream': 'ext://sys.stdout'
        },
        
        'file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'app.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        },
        
        # 为 storage 模块创建独立日志文件
        'storage_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'storage.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        },
        
        # 为 API 模块创建独立日志文件
        'api_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'INFO',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'api.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        },
        
        # 为 database 模块创建独立日志文件
        'database_file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'database.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        }
    },
    
    'loggers': {
        # 根日志记录器
        '': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # storage 模块独立日志
        'services.storage': {
            'handlers': ['console', 'file', 'storage_file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # API 模块独立日志
        'api': {
            'handlers': ['console', 'file', 'api_file'],
            'level': 'INFO',
            'propagate': False
        },
        
        # database 模块独立日志
        'models.database': {
            'handlers': ['console', 'file', 'database_file'],
            'level': 'DEBUG',
            'propagate': False
        }
    }
}
```

**使用方式**（代码中不需要任何特殊处理）：

```python
# services/storage.py
from utils.logger import get_logger

logger = get_logger(__name__)  # 自动使用 'services.storage' 的配置
logger.info("这条日志会记录到 app.log 和 storage.log")
```

### 6.5 日志文件结构示例

配置完成后，日志目录结构如下：

```
logs/
├── app.log              # 所有模块的日志（汇总）
├── app.log.2024-01-01
├── storage.log          # 只包含 storage 模块的日志
├── storage.log.2024-01-01
├── api.log              # 只包含 API 模块的日志
├── api.log.2024-01-01
├── database.log         # 只包含 database 模块的日志
└── database.log.2024-01-01
```

### 6.6 注意事项

1. **避免重复记录**：
   - 设置 `propagate: False` 防止日志向上传播
   - 如果某个模块的 logger 同时有独立 handler 和根 logger 的 handler，日志会同时记录到多个文件（这是正常的）

2. **日志级别设置**：
   - 可以为不同模块设置不同的日志级别
   - 例如：API 模块使用 INFO，数据库模块使用 DEBUG

3. **文件命名规范**：
   - 使用模块名或功能名作为日志文件名
   - 例如：`storage.log`、`api.log`、`database.log`

4. **性能考虑**：
   - 每个独立的日志文件都会增加 I/O 操作
   - 不要为太多模块创建独立日志文件，建议只用于关键模块

### 6.7 常见使用场景

#### 场景1：数据库操作日志单独记录

```python
# config/logging_config.py
'database_file': {
    'class': 'logging.handlers.TimedRotatingFileHandler',
    'level': 'DEBUG',
    'formatter': 'detailed',
    'filename': os.path.join(LOG_DIR, 'database.log'),
    'when': 'midnight',
    'interval': 1,
    'backupCount': 30,
    'encoding': 'utf-8'
}

# loggers
'models.database': {
    'handlers': ['console', 'file', 'database_file'],
    'level': 'DEBUG',
    'propagate': False
}
```

#### 场景2：API 请求日志单独记录

```python
# config/logging_config.py
'api_file': {
    'class': 'logging.handlers.TimedRotatingFileHandler',
    'level': 'INFO',
    'formatter': 'standard',
    'filename': os.path.join(LOG_DIR, 'api.log'),
    'when': 'midnight',
    'interval': 1,
    'backupCount': 30,
    'encoding': 'utf-8'
}

# loggers
'api': {
    'handlers': ['console', 'file', 'api_file'],
    'level': 'INFO',
    'propagate': False
}
```

#### 场景3：第三方库日志单独记录

```python
# config/logging_config.py
'third_party_file': {
    'class': 'logging.handlers.TimedRotatingFileHandler',
    'level': 'WARNING',
    'formatter': 'detailed',
    'filename': os.path.join(LOG_DIR, 'third_party.log'),
    'when': 'midnight',
    'interval': 1,
    'backupCount': 7,  # 第三方库日志保留时间短一些
    'encoding': 'utf-8'
}

# loggers
'requests': {  # 例如：requests 库
    'handlers': ['third_party_file'],
    'level': 'WARNING',
    'propagate': False
}
```

### 6.8 为独立日志文件添加时间戳（每次运行生成新文件）

如果你希望每次运行程序时，为特定模块生成一个带时间戳的新日志文件（而不是追加到同一个文件），可以使用以下方法。

#### 方法一：在配置文件中使用动态文件名（推荐）

修改 `config/logging_config.py`，在文件名中添加时间戳：

```python
"""
日志配置文件
为特定模块配置带时间戳的独立日志文件
"""

import os
import logging
import logging.config
from logging.handlers import TimedRotatingFileHandler, FileHandler
from datetime import datetime

# 获取项目根目录
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# 日志目录
LOG_DIR = os.path.join(BASE_DIR, 'logs')

# 确保日志目录存在
if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)

# 生成带时间戳的文件名
def get_timestamped_filename(base_name):
    """
    生成带时间戳的文件名
    
    参数:
        base_name: 基础文件名（如 'storage'）
    
    返回:
        带时间戳的文件名（如 'storage_2024-01-15_10-30-45.log'）
    """
    timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    return f"{base_name}_{timestamp}.log"

# 在程序启动时生成时间戳（所有模块使用同一个时间戳，便于关联）
STARTUP_TIMESTAMP = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')

# 日志配置字典
LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    
    'formatters': {
        'standard': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        },
        'detailed': {
            'format': '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        }
    },
    
    'handlers': {
        # 控制台输出
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'stream': 'ext://sys.stdout'
        },
        
        # 文件输出 - 所有日志（使用按天轮转）
        'file': {
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, 'app.log'),
            'when': 'midnight',
            'interval': 1,
            'backupCount': 30,
            'encoding': 'utf-8'
        },
        
        # ⭐ 为 storage 模块配置带时间戳的独立日志文件
        'storage_file': {
            'class': 'logging.FileHandler',  # 使用 FileHandler，每次运行新文件
            'level': 'DEBUG',
            'formatter': 'detailed',
            'filename': os.path.join(LOG_DIR, f'storage_{STARTUP_TIMESTAMP}.log'),  # 带时间戳
            'mode': 'w',  # 每次运行覆盖（如果不想覆盖，使用 'a'）
            'encoding': 'utf-8'
        },
        
        # ⭐ 为 API 模块配置带时间戳的独立日志文件
        'api_file': {
            'class': 'logging.FileHandler',
            'level': 'INFO',
            'formatter': 'standard',
            'filename': os.path.join(LOG_DIR, f'api_{STARTUP_TIMESTAMP}.log'),
            'mode': 'w',
            'encoding': 'utf-8'
        }
    },
    
    'loggers': {
        # 根日志记录器
        '': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # storage 模块独立日志
        'services.storage': {
            'handlers': ['console', 'file', 'storage_file'],
            'level': 'DEBUG',
            'propagate': False
        },
        
        # API 模块独立日志
        'api': {
            'handlers': ['console', 'file', 'api_file'],
            'level': 'INFO',
            'propagate': False
        }
    }
}
```

**结果**：
- 每次运行程序时，会生成新的日志文件：
  - `storage_2024-01-15_10-30-45.log`
  - `api_2024-01-15_10-30-45.log`
- 所有模块使用同一个时间戳，便于关联同一运行周期的日志

#### 方法二：在代码中动态创建带时间戳的日志文件

如果不想修改配置文件，也可以在代码中动态创建：

```python
"""
services/storage.py
为 storage 模块创建带时间戳的独立日志文件
"""

import logging
from logging import FileHandler
import os
from datetime import datetime
from config import LOG_DIR

# 生成时间戳
timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')

# 获取当前模块的 logger
logger = logging.getLogger(__name__)

# 创建带时间戳的日志文件路径
storage_log_file = os.path.join(LOG_DIR, f'storage_{timestamp}.log')

# 创建文件处理器
storage_handler = FileHandler(
    filename=storage_log_file,
    mode='w',  # 每次运行新文件
    encoding='utf-8'
)
storage_handler.setLevel(logging.DEBUG)

# 设置格式
formatter = logging.Formatter(
    '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
storage_handler.setFormatter(formatter)

# 添加处理器到 logger
logger.addHandler(storage_handler)

# 使用 logger
logger.info(f"Storage 模块日志文件: {storage_log_file}")
logger.info("这条日志会记录到带时间戳的文件中")
```

#### 方法三：使用工具函数创建带时间戳的日志文件

创建一个工具函数，方便为任意模块创建带时间戳的日志文件：

```python
"""
utils/logger.py
添加创建带时间戳日志文件的工具函数
"""

import logging
from logging import FileHandler
import os
from datetime import datetime

def create_timestamped_module_logger(module_name, log_file_base_name, level=logging.DEBUG):
    """
    为特定模块创建带时间戳的独立日志文件
    
    参数:
        module_name: 模块名称（通常是 __name__）
        log_file_base_name: 日志文件基础名称（如 'storage'，会自动添加时间戳）
        level: 日志级别
    
    返回:
        Logger 对象和日志文件路径的元组
    
    使用示例:
        logger, log_file = create_timestamped_module_logger(__name__, 'storage.log')
        logger.info(f"日志文件: {log_file}")
    """
    from config import LOG_DIR
    
    # 生成时间戳
    timestamp = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
    
    # 获取 logger
    logger = logging.getLogger(module_name)
    
    # 创建带时间戳的日志文件路径
    # 如果 log_file_base_name 已经包含 .log，则替换；否则添加
    if log_file_base_name.endswith('.log'):
        base_name = log_file_base_name[:-4]  # 移除 .log
        log_file_name = f"{base_name}_{timestamp}.log"
    else:
        log_file_name = f"{log_file_base_name}_{timestamp}.log"
    
    log_file_path = os.path.join(LOG_DIR, log_file_name)
    
    # 创建文件处理器
    handler = FileHandler(
        filename=log_file_path,
        mode='w',  # 每次运行新文件
        encoding='utf-8'
    )
    handler.setLevel(level)
    
    # 设置格式
    formatter = logging.Formatter(
        '%(asctime)s [%(levelname)s] %(name)s:%(filename)s:%(lineno)d [%(funcName)s] - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    
    # 添加处理器
    logger.addHandler(handler)
    
    return logger, log_file_path
```

**使用示例**：

```python
"""
services/storage.py
"""

from utils.logger import create_timestamped_module_logger
import logging

# 为当前模块创建带时间戳的日志文件
logger, log_file = create_timestamped_module_logger(__name__, 'storage', logging.DEBUG)

logger.info(f"Storage 模块日志文件: {log_file}")
logger.info("这条日志会记录到带时间戳的文件中")
```

### 6.9 时间戳格式选项

你可以根据需要选择不同的时间戳格式：

```python
from datetime import datetime

# 格式1：日期和时间（推荐）
timestamp1 = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
# 结果：2024-01-15_10-30-45

# 格式2：只包含日期
timestamp2 = datetime.now().strftime('%Y-%m-%d')
# 结果：2024-01-15

# 格式3：包含毫秒
timestamp3 = datetime.now().strftime('%Y-%m-%d_%H-%M-%S-%f')[:-3]  # 毫秒取前3位
# 结果：2024-01-15_10-30-45-123

# 格式4：ISO 格式
timestamp4 = datetime.now().isoformat().replace(':', '-').split('.')[0]
# 结果：2024-01-15T10-30-45

# 格式5：Unix 时间戳
import time
timestamp5 = str(int(time.time()))
# 结果：1705291845
```

**推荐使用格式1**（`%Y-%m-%d_%H-%M-%S`），因为：
- 可读性好
- 按文件名排序时，时间顺序正确
- 包含足够的信息来区分不同的运行

### 6.10 日志文件结构示例（带时间戳）

使用带时间戳的配置后，日志目录结构如下：

```
logs/
├── app.log                    # 所有模块的日志（汇总，按天轮转）
├── app.log.2024-01-15
├── storage_2024-01-15_10-30-45.log    # 第一次运行的 storage 日志
├── storage_2024-01-15_14-20-30.log    # 第二次运行的 storage 日志
├── storage_2024-01-16_09-15-00.log    # 第三次运行的 storage 日志
├── api_2024-01-15_10-30-45.log        # 第一次运行的 API 日志
├── api_2024-01-15_14-20-30.log        # 第二次运行的 API 日志
└── api_2024-01-16_09-15-00.log        # 第三次运行的 API 日志
```

### 6.11 注意事项

1. **文件模式选择**：
   - `mode='w'`：每次运行覆盖文件（如果文件名相同）
   - `mode='a'`：追加模式（不推荐，因为文件名带时间戳不会重复）

2. **时间戳生成时机**：
   - 在程序启动时生成一次时间戳，所有模块使用同一个时间戳
   - 这样可以关联同一运行周期的不同模块日志

3. **文件清理**：
   - 带时间戳的日志文件不会自动清理
   - 建议添加定期清理脚本，删除过期的日志文件

4. **性能考虑**：
   - 每次运行创建新文件会增加文件系统操作
   - 如果运行频率很高，考虑使用按天轮转而不是每次运行新文件

### 6.12 清理旧日志文件的脚本示例

创建一个清理脚本 `scripts/cleanup_logs.py`：

```python
"""
清理旧的带时间戳的日志文件
"""

import os
import glob
from datetime import datetime, timedelta
from config import LOG_DIR

def cleanup_old_logs(days_to_keep=7):
    """
    清理指定天数之前的带时间戳的日志文件
    
    参数:
        days_to_keep: 保留最近多少天的日志文件
    """
    # 获取所有带时间戳的日志文件
    pattern = os.path.join(LOG_DIR, '*_*.log')
    log_files = glob.glob(pattern)
    
    # 计算截止日期
    cutoff_date = datetime.now() - timedelta(days=days_to_keep)
    
    deleted_count = 0
    for log_file in log_files:
        # 从文件名中提取时间戳
        filename = os.path.basename(log_file)
        try:
            # 假设文件名格式：module_YYYY-MM-DD_HH-MM-SS.log
            timestamp_str = filename.split('_', 1)[1].replace('.log', '')
            file_date = datetime.strptime(timestamp_str, '%Y-%m-%d_%H-%M-%S')
            
            # 如果文件日期早于截止日期，删除
            if file_date < cutoff_date:
                os.remove(log_file)
                deleted_count += 1
                print(f"删除旧日志文件: {filename}")
        except (ValueError, IndexError):
            # 如果文件名格式不符合预期，跳过
            continue
    
    print(f"清理完成，删除了 {deleted_count} 个旧日志文件")

if __name__ == '__main__':
    cleanup_old_logs(days_to_keep=7)  # 保留最近7天的日志
```

### 6.13 总结

为独立日志文件添加时间戳的步骤：

1. ✅ **选择文件处理器**：使用 `FileHandler` 而不是 `TimedRotatingFileHandler`
2. ✅ **生成时间戳**：在程序启动时生成时间戳（所有模块共享）
3. ✅ **构建文件名**：将时间戳添加到文件名中
4. ✅ **配置 handler**：在配置文件中或代码中创建带时间戳的 handler
5. ✅ **设置文件模式**：使用 `mode='w'`（每次运行新文件）

**推荐使用方法一（配置文件方式）**，因为：
- 配置集中管理
- 所有模块使用同一个时间戳，便于关联
- 代码中无需特殊处理

**适用场景**：
- 需要区分不同运行周期的日志
- 每次运行都是独立的测试或任务
- 需要保留每次运行的完整日志记录

---

### 6.14 总结

为特定模块配置独立日志文件的步骤：

1. ✅ **在配置文件中创建独立的 handler**：指向独立的日志文件
2. ✅ **为模块创建独立的 logger**：使用模块名（通常是 `__name__`）
3. ✅ **将独立 handler 添加到 logger**：在 logger 的 handlers 列表中添加
4. ✅ **设置 propagate: False**：避免日志重复记录
5. ✅ **在代码中使用**：正常使用 `get_logger(__name__)` 即可

**带时间戳的日志文件**：
- 使用 `FileHandler` 而不是 `TimedRotatingFileHandler`
- 在文件名中添加时间戳（如 `storage_2024-01-15_10-30-45.log`）
- 每次运行生成新的日志文件

**推荐使用方法一（配置文件方式）**，因为：
- 配置集中管理，易于维护
- 不会导致日志重复记录
- 代码中无需特殊处理
- 符合企业级项目的最佳实践

---

## 7. 日志级别使用

### 6.1 日志级别说明

| 级别 | 数值 | 使用场景 | 示例 |
|------|------|----------|------|
| **DEBUG** | 10 | 详细的调试信息，通常只在开发时使用 | 函数参数值、中间变量值 |
| **INFO** | 20 | 一般信息，记录程序正常运行的关键步骤 | 用户操作、业务逻辑执行 |
| **WARNING** | 30 | 警告信息，程序可以继续运行但需要注意 | 配置缺失、性能问题 |
| **ERROR** | 40 | 错误信息，程序遇到错误但可以继续运行 | 文件读取失败、网络请求失败 |
| **CRITICAL** | 50 | 严重错误，程序可能无法继续运行 | 数据库连接失败、系统资源耗尽 |

### 5.2 日志级别使用指南

#### DEBUG 级别
- 函数入口和出口
- 关键变量的值
- 算法执行的中间步骤
- 详细的执行流程

```python
logger.debug(f"函数调用: {function_name}(args={args}, kwargs={kwargs})")
logger.debug(f"变量值: user_id={user_id}, task_id={task_id}")
```

#### INFO 级别
- 业务流程的关键节点
- 用户操作记录
- 系统状态变化
- 重要的业务事件

```python
logger.info(f"用户 {user_id} 添加了任务: {task_title}")
logger.info(f"任务 {task_id} 状态更新为: {status}")
logger.info(f"系统启动成功，加载了 {task_count} 个任务")
```

#### WARNING 级别
- 非致命性错误
- 配置问题
- 性能警告
- 资源使用警告

```python
logger.warning(f"配置文件 {config_file} 不存在，使用默认配置")
logger.warning(f"任务列表为空，用户 {user_id} 可能没有创建过任务")
logger.warning(f"文件大小超过阈值: {file_size}MB，可能影响性能")
```

#### ERROR 级别
- 异常捕获
- 操作失败
- 外部资源访问失败
- 数据验证失败

```python
logger.error(f"文件读取失败: file_path={file_path}, error={str(e)}")
logger.error(f"任务保存失败: task_id={task_id}, error={str(e)}")
logger.error(f"数据库连接失败: host={host}, port={port}, error={str(e)}")
```

#### CRITICAL 级别
- 系统级错误
- 无法恢复的错误
- 需要立即关注的问题

```python
logger.critical(f"数据库连接池耗尽，系统无法继续运行")
logger.critical(f"磁盘空间不足，无法写入日志文件")
```

---

## 8. 日志添加位置

### 6.1 函数入口

**目的**：记录函数调用和参数，便于追踪执行流程

**位置**：函数开始处，参数验证之后

**示例**：
```python
def add_task(self, title, description=''):
    """
    添加新任务
    """
    logger.info(f"开始添加任务: title={title}, description={description}")
    logger.debug(f"函数参数: title={title}, description={description}")
    
    if not title:
        logger.warning("任务标题为空，添加失败")
        return None
    
    # ... 业务逻辑 ...
```

**在你的项目中的应用**：
- `TaskService.add_task()` - 记录任务添加请求
- `TaskService.complete_task()` - 记录任务完成请求
- `TaskService.delete_task()` - 记录任务删除请求
- `Storage.load_tasks()` - 记录数据加载操作
- `Storage.save_tasks()` - 记录数据保存操作

### 6.2 关键分支

**目的**：记录条件判断的结果，帮助理解程序执行路径

**位置**：if/else、switch/case 等分支语句中

**示例**：
```python
if task and not task.completed:
    logger.info(f"任务 {task_id} 存在且未完成，可以标记为已完成")
    task.completed = True
    return self._save_tasks()
else:
    if not task:
        logger.warning(f"任务 {task_id} 不存在")
    else:
        logger.info(f"任务 {task_id} 已完成，无需重复操作")
    return False
```

**在你的项目中的应用**：
- `TaskService.complete_task()` - 判断任务是否存在和是否已完成
- `TaskService.delete_task()` - 判断任务是否存在
- `main()` - 判断用户选择的操作类型

### 6.3 异常捕获

**目的**：记录异常信息，便于问题排查

**位置**：try-except 块的 except 子句中

**示例**：
```python
try:
    with open(TASKS_FILE, 'r', encoding='utf-8') as f:
        tasks = json.load(f)
    logger.info(f"成功加载 {len(tasks)} 个任务")
    return tasks if isinstance(tasks, list) else []
except json.JSONDecodeError as e:
    logger.error(f"JSON 解析失败: file_path={TASKS_FILE}, error={str(e)}", exc_info=True)
    return []
except IOError as e:
    logger.error(f"文件读取失败: file_path={TASKS_FILE}, error={str(e)}", exc_info=True)
    return []
except Exception as e:
    logger.critical(f"未知错误: file_path={TASKS_FILE}, error={str(e)}", exc_info=True)
    return []
```

**关键点**：
- 使用 `exc_info=True` 记录完整的异常堆栈信息
- 记录相关的上下文信息（文件路径、参数等）
- 根据异常严重程度选择日志级别

**在你的项目中的应用**：
- `Storage.load_tasks()` - 捕获文件读取和 JSON 解析异常
- `Storage.save_tasks()` - 捕获文件写入异常
- `main()` - 捕获用户输入转换异常（ValueError）

### 6.4 外部资源交互

**目的**：记录与外部系统的交互，便于追踪问题

**位置**：数据库操作、文件操作、网络请求前后

**示例**：
```python
def save_tasks(self, tasks):
    """
    将任务列表保存到 JSON 文件
    """
    logger.info(f"开始保存任务: 任务数量={len(tasks)}, 文件路径={TASKS_FILE}")
    
    try:
        # 保存前记录
        logger.debug(f"准备写入文件: {TASKS_FILE}")
        
        with open(TASKS_FILE, 'w', encoding='utf-8') as f:
            json.dump(tasks, f, ensure_ascii=False, indent=2)
        
        # 保存后记录
        file_size = os.path.getsize(TASKS_FILE)
        logger.info(f"任务保存成功: 文件大小={file_size} bytes")
        return True
        
    except IOError as e:
        logger.error(f"文件写入失败: file_path={TASKS_FILE}, error={str(e)}", exc_info=True)
        return False
```

**在你的项目中的应用**：
- `Storage.load_tasks()` - 文件读取操作
- `Storage.save_tasks()` - 文件写入操作
- 如果将来添加数据库，记录数据库连接和查询操作

### 6.5 传参位置

**目的**：记录函数调用时传入的参数，特别是敏感参数需要脱敏

**位置**：函数开始处，参数验证之前或之后

**示例**：
```python
def add_task(self, title, description=''):
    """
    添加新任务
    """
    # 记录传入的参数
    logger.debug(f"接收参数: title={title}, description={description}")
    
    # 参数验证
    if not title:
        logger.warning("任务标题为空")
        return None
    
    # 记录验证后的参数（如果需要处理敏感信息）
    logger.info(f"添加任务: title={title[:50]}...")  # 截断过长的标题
    
    # ... 业务逻辑 ...
```

**注意事项**：
- **敏感信息脱敏**：密码、token、密钥等不应记录到日志
- **参数长度限制**：过长的参数可以截断或摘要
- **参数类型检查**：记录参数类型有助于调试

**在你的项目中的应用**：
- `TaskService.add_task()` - 记录任务标题和描述
- `TaskService.complete_task()` - 记录任务 ID
- `TaskService.delete_task()` - 记录任务 ID
- `main()` - 记录用户输入的选择和任务信息

### 6.6 函数返回位置

**目的**：记录函数返回值，特别是关键业务函数的返回值

**位置**：return 语句之前

**示例**：
```python
def get_task_by_id(self, task_id):
    """
    根据 ID 获取任务
    """
    logger.debug(f"查询任务: task_id={task_id}")
    
    for task in self.tasks:
        if task.id == task_id:
            logger.info(f"找到任务: task_id={task_id}, title={task.title}")
            return task
    
    logger.warning(f"任务不存在: task_id={task_id}")
    return None
```

**在你的项目中的应用**：
- `TaskService.get_task_by_id()` - 记录查询结果
- `TaskService.add_task()` - 记录新创建的任务 ID
- `Storage.load_tasks()` - 记录加载的任务数量

### 6.7 业务流程关键节点

**目的**：记录业务流程的重要步骤，便于追踪业务执行过程

**位置**：业务流程的关键步骤之间

**示例**：
```python
def add_task(self, title, description=''):
    """
    添加新任务
    """
    logger.info(f"开始添加任务: title={title}")
    
    # 步骤1：获取下一个 ID
    task_id = self._get_next_id()
    logger.debug(f"生成任务 ID: {task_id}")
    
    # 步骤2：创建任务对象
    new_task = Task(task_id=task_id, title=title, description=description)
    logger.debug(f"创建任务对象: {new_task}")
    
    # 步骤3：添加到列表
    self.tasks.append(new_task)
    logger.debug(f"任务已添加到内存列表，当前任务数: {len(self.tasks)}")
    
    # 步骤4：保存到文件
    if self._save_tasks():
        logger.info(f"任务添加成功: task_id={task_id}, title={title}")
        return new_task
    else:
        logger.error(f"任务保存失败，已回滚: task_id={task_id}")
        self.tasks.pop()
        return None
```

---

## 9. 实践步骤

### 步骤 1：创建日志配置

1. 在 `config/` 目录下创建 `logging_config.py` 文件
2. 按照第 2 节的配置示例编写配置
3. 确保日志目录路径正确

### 步骤 2：创建日志工具模块

1. 在 `utils/` 目录下创建 `logger.py` 文件
2. 实现 `setup_logging()` 和 `get_logger()` 函数
3. 确保日志系统在模块导入时自动初始化

### 步骤 3：更新 config.py

1. 在 `config.py` 中添加 `LOG_DIR` 配置
2. 确保日志目录在项目启动时被创建

### 步骤 4：在主程序中初始化日志

1. 在 `main.py` 文件开头导入日志模块
2. 在 `main()` 函数开始处记录程序启动日志

```python
from utils.logger import get_logger

logger = get_logger(__name__)

def main():
    """主函数"""
    logger.info("=" * 50)
    logger.info("任务管理器启动")
    logger.info("=" * 50)
    
    # ... 原有代码 ...
```

### 步骤 5：在服务层添加日志

1. 在 `services/task_service.py` 中添加日志
   - 导入日志模块
   - 在类初始化时创建 logger
   - 在每个方法的关键位置添加日志

2. 在 `services/storage.py` 中添加日志
   - 导入日志模块
   - 在类初始化时创建 logger
   - 在文件读写操作前后添加日志
   - 在异常捕获处添加错误日志

### 步骤 6：在模型层添加日志（可选）

1. 在 `models/task.py` 中添加日志（如果需要）
   - 记录对象创建
   - 记录对象转换操作

### 步骤 7：在主程序流程中添加日志

1. 在 `main.py` 的各个分支添加日志
   - 用户选择操作时
   - 操作成功/失败时
   - 异常捕获时

### 步骤 8：测试日志功能

1. 运行程序，执行各种操作
2. 检查控制台输出
3. 检查 `logs/` 目录下的日志文件
4. 验证日志格式是否正确
5. 验证日志轮转是否正常工作

---

## 10. 最佳实践

### 8.1 日志记录原则

1. **结构化日志**：使用键值对格式，便于后续解析和分析
   ```python
   # 好的做法
   logger.info(f"任务添加成功: task_id={task_id}, title={title}, user_id={user_id}")
   
   # 不好的做法
   logger.info(f"任务添加成功: {task_id}, {title}, {user_id}")
   ```

2. **上下文信息**：记录足够的上下文，便于问题定位
   ```python
   logger.error(f"文件读取失败: file_path={file_path}, file_size={file_size}, error={str(e)}")
   ```

3. **避免日志注入**：对用户输入进行适当的转义
   ```python
   # 如果用户输入可能包含特殊字符，需要处理
   safe_title = title.replace('\n', '\\n').replace('\r', '\\r')
   logger.info(f"添加任务: title={safe_title}")
   ```

4. **性能考虑**：在高频调用的地方，使用适当的日志级别
   ```python
   # 在循环中使用 DEBUG 而不是 INFO
   for task in tasks:
       logger.debug(f"处理任务: {task.id}")  # 而不是 logger.info
   ```

### 8.2 日志级别选择

- **开发环境**：使用 DEBUG 级别，记录详细信息
- **测试环境**：使用 INFO 级别，记录关键信息
- **生产环境**：使用 INFO 或 WARNING 级别，避免过多日志

可以通过环境变量控制日志级别：

```python
import os

# 从环境变量读取日志级别
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO').upper()
LOGGING_CONFIG['loggers']['']['level'] = LOG_LEVEL
```

### 8.3 日志文件管理

1. **日志轮转**：使用 `TimedRotatingFileHandler` 按天轮转
2. **日志保留**：根据业务需求设置保留天数
3. **日志压缩**：对于长期保留的日志，可以考虑压缩存储
4. **日志清理**：定期清理过期日志，避免磁盘空间不足

### 8.4 敏感信息处理

1. **密码**：永远不要记录密码
2. **Token**：记录 token 的前几位和后几位，中间用 `***` 替代
3. **个人信息**：根据合规要求，可能需要脱敏处理
4. **文件路径**：如果路径包含敏感信息，需要处理

```python
def mask_sensitive_data(data):
    """脱敏处理"""
    if isinstance(data, str) and len(data) > 8:
        return data[:4] + '***' + data[-4:]
    return '***'

logger.info(f"用户登录: user_id={user_id}, token={mask_sensitive_data(token)}")
```

### 8.5 日志监控和告警

在生产环境中，应该：
1. **监控日志文件大小**：避免日志文件过大
2. **监控错误日志**：设置告警，当错误日志过多时通知
3. **日志聚合**：使用 ELK、Splunk 等工具聚合和分析日志
4. **性能监控**：记录关键操作的执行时间

```python
import time

def log_execution_time(func):
    """记录函数执行时间的装饰器"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            execution_time = time.time() - start_time
            logger.info(f"函数执行完成: function={func.__name__}, time={execution_time:.2f}s")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"函数执行失败: function={func.__name__}, time={execution_time:.2f}s, error={str(e)}")
            raise
    return wrapper
```

### 8.6 代码示例总结

#### 完整的服务类日志示例

```python
"""
任务服务类（带完整日志）
"""

import logging
from models.task import Task
from services.storage import Storage

logger = logging.getLogger(__name__)


class TaskService:
    """任务服务类，管理所有任务相关的操作"""
    
    def __init__(self):
        """初始化任务服务，加载已有任务"""
        logger.info("初始化 TaskService")
        self.storage = Storage()
        self.tasks = self._load_tasks()
        logger.info(f"TaskService 初始化完成，加载了 {len(self.tasks)} 个任务")
    
    def _load_tasks(self):
        """从存储中加载任务列表"""
        logger.debug("开始加载任务列表")
        tasks_data = self.storage.load_tasks()
        tasks = [Task.from_dict(task_dict) for task_dict in tasks_data]
        logger.info(f"任务列表加载完成: 数量={len(tasks)}")
        return tasks
    
    def _save_tasks(self):
        """将当前任务列表保存到文件"""
        logger.debug(f"开始保存任务列表: 任务数量={len(self.tasks)}")
        tasks_dict = [task.to_dict() for task in self.tasks]
        result = self.storage.save_tasks(tasks_dict)
        if result:
            logger.info(f"任务列表保存成功: 任务数量={len(self.tasks)}")
        else:
            logger.error(f"任务列表保存失败: 任务数量={len(self.tasks)}")
        return result
    
    def add_task(self, title, description=''):
        """添加新任务"""
        logger.info(f"开始添加任务: title={title}, description_length={len(description)}")
        
        if not title:
            logger.warning("任务标题为空，添加失败")
            return None
        
        task_id = self._get_next_id()
        logger.debug(f"生成任务 ID: {task_id}")
        
        new_task = Task(
            task_id=task_id,
            title=title,
            description=description,
            completed=False
        )
        
        self.tasks.append(new_task)
        logger.debug(f"任务已添加到内存列表: task_id={task_id}")
        
        if self._save_tasks():
            logger.info(f"任务添加成功: task_id={task_id}, title={title}")
            return new_task
        else:
            logger.error(f"任务保存失败，已回滚: task_id={task_id}")
            self.tasks.pop()
            return None
    
    def complete_task(self, task_id):
        """标记任务为已完成"""
        logger.info(f"开始标记任务为已完成: task_id={task_id}")
        
        task = self.get_task_by_id(task_id)
        if task and not task.completed:
            logger.debug(f"任务存在且未完成: task_id={task_id}, title={task.title}")
            task.completed = True
            if self._save_tasks():
                logger.info(f"任务标记为已完成: task_id={task_id}")
                return True
            else:
                logger.error(f"任务状态保存失败: task_id={task_id}")
                return False
        else:
            if not task:
                logger.warning(f"任务不存在: task_id={task_id}")
            else:
                logger.info(f"任务已完成，无需重复操作: task_id={task_id}")
            return False
    
    def delete_task(self, task_id):
        """删除任务"""
        logger.info(f"开始删除任务: task_id={task_id}")
        
        task = self.get_task_by_id(task_id)
        if task:
            logger.debug(f"找到要删除的任务: task_id={task_id}, title={task.title}")
            self.tasks.remove(task)
            if self._save_tasks():
                logger.info(f"任务删除成功: task_id={task_id}")
                return True
            else:
                logger.error(f"任务删除后保存失败: task_id={task_id}")
                return False
        else:
            logger.warning(f"要删除的任务不存在: task_id={task_id}")
            return False
```

---

## 11. 常见问题

### Q1: 日志文件太大怎么办？
**A**: 使用 `TimedRotatingFileHandler` 按天轮转，并设置合理的 `backupCount`。

### Q2: 如何在不同环境使用不同的日志级别？
**A**: 通过环境变量或配置文件控制日志级别。

### Q3: 日志会影响性能吗？
**A**: 会，但影响很小。在高频调用的地方使用 DEBUG 级别，生产环境可以关闭。

### Q4: 如何查看日志文件？
**A**: 使用 `tail -f logs/app.log` 实时查看，或使用文本编辑器打开。

### Q5: 日志格式可以自定义吗？
**A**: 可以，在 `formatters` 中定义自己的格式。

---

## 12. 总结

添加企业级日志系统需要：
1. ✅ 创建日志配置文件
2. ✅ 创建日志工具模块
3. ✅ 在关键位置添加日志记录
4. ✅ 选择合适的日志级别
5. ✅ 使用合适的日志格式
6. ✅ 管理日志文件（轮转、保留）
7. ✅ 处理敏感信息
8. ✅ 测试日志功能

按照本指南的步骤，你可以逐步为项目添加完善的日志系统。记住：好的日志系统是问题排查和系统维护的重要工具！

---
## 13.附录

### 13.1 logging 模块的整体结构
```
logging 模块
├─ 根模块（基础功能）：
│  ├─ FileHandler  ：基础文件日志处理器
│  └─ StreamHandler ：控制台日志处理器
├─ 子模块 logging.handlers（高级功能）：
│  ├─ RotatingFileHandler ：按大小分割日志
│  ├─ TimedRotatingFileHandler ：按时间分割日志
│  ├─ SMTPHandler ：日志发邮件
│  └─ SysLogHandler ：写入系统日志
└─ 其他核心组件：日志级别、格式器(formatter)等
```
---




**祝你学习顺利！** 🎉
